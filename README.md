# Tema3-SD
Tema3-Structuri de date-Grafuri
Pentru reprezentarea structurii de graf din Problema 1 a temei, am definit tipul 'graph' astfel incat acesta sa contina un tablou bidimensional de caractere alocat dinamic in care am memorat numele actorilor din fisierul de intrare (in ordinea in care apar in fisier si eliminand aparitiile multiple ale unui actor), si o structura de tip lista pentru listele de adiacenta asociate actorilor. Pentru o eficienta mai buna a construirii grafului dar si a parcurgerii acestuia, am adaugat in listele de adiacenta doar indicele asociat unui actor (preluat prin intermediul tabloului din graf "char** nodes", cu valori de la 0 la nr_de_noduri_din_graf-1), nu si numele acestora, ele putand fie extrase din tabloul mentionat anterior. In cadrul functiei in care se realizeaza citirea grafului ("void readGraph(FILE *fp, graph *g)"), am adaugat treptat in graf noduri si muchii odata cu citirea datelor asociaate unui film. Astfel, am memorat intr-un tablou bidimensional de caractere alocat dinamic (char** actor) numele actorilor care joaca intr-un anume film si am adaugat initial in graf nodurile (apeland functia cu antetul "void addVertex(graph* g, char* name)" pentru fiecare element al tabloului), prin adaugarea unui nou element in taboul "nodes" din structura grafului, apoi am adaugat muchii intre nodurile inserate anterior; pentru a adauga muchii intre actorii care joaca intr-un anume film, am folosit acelasi tablou din functia 'readGraph', cel ce memoreaza numele actorilor dintr-un anume film, accesand lista de adiacenta prin intermediul indicelui din tabloul 'actor'; de asemenea, in rezolvare am folosit si functia getPos: acesta returneaza indicele asociat unui actor in graf, cautand in tabloul bidimensional de caractere al grafului numele acelui actor (daca actorul nu este prezent in graf functia va returna valoarea -1). 
Pentru a rezolva prima cerinta a temei (numarul de productii independente din graf), am folosit algoritmul de pargurgere in latime al grafului in scopul determinarii numarului de componente conexe din graf. Astfel, am realizat parcurgerea in adancime a garfului; am parcurs pe rand nodurile inca nevizitate ale acestuia, numarul de apeluri al functiei de parcurgere in latime  fiind deci numarul de componente conexe al grafului. 
Pentru a determina gradul de inrudire dintre 2 actori (cerinta 2) am folosit algoritmul de parcurgere in adancime, introducand un vector suplimentar, intializat cu valori de 0, in care sunt memorate distantele de la nodul de start la celelalte noduri ale grafului. Am considerat ca nod de start pentu BFS nodul din graf asociat unuia dintre cei 2 actori, gasind indicii celor 2 actori din graf cu ajutorul functiei 'getPos'; distanta de la nodul de start la un nod j la fi memorata in componenta de indice j din vectorul de distante (declarat 'distances' in functia cu antetul "int affinityDegree(graph g,FILE *fp) ".
Pentru rezolvarea celei de-a treia cerinte, determinarea punctelor de articulatie din graf, am folosit Algoritmul lui Tarjan, urmarind pseudocodul din enuntul temei. Pentru retinerea in ordine alfabetica a punctelor de articulatie am considerat ca este utila o structura de tip arbore binar de cautare pentru a nu mai fie nevoie de o sortare ulterioara e punctelor daca acestea ar fi inserate, de pilda, intr-un tablou bidimensional de caractere. Pentru 'a simula' arborele care rezulta in urma parcurgerii in adancime am folosit un vector de indici, astfel incat fiecare componenta a acestui vector sa memoreze indicele nodului 'parinte' din parcurgerea in adancime a grafului. In acest caz, un nod din graf este nod radacina (pentru BFS) daca nu are asociat un indice in vectorul de parinti (pentru aceasta am intializat vectorul de parinti cu valori de -1). Toti vectorii folositi in cadrul algorimului sunt alocati dinamic, cu o dimensiune egala cu numarul de componente din graf.
Am incercat si implementarea cerintei bonus, determinarea clicii maximale a grafului, rezultatele obtinute fiind corecte doar pentru o parte din teste, intrucat la celelalte obtin clici de dimeniuni mai mici decat cele corecte. Pentru implementare am respectat sugestia din enunt, folosind pentru reprezentrarea multimilor CA, CS si NOT aceeasi structura de arbore binar de cautare ca si in cazul cerintei 3. Am incercat sa adaptez pseudocodul din enunt, definind functii suplimentare pentru a opera cu 'multimile' amintite mai sus. Pentru a extrage primul element din multimea 'candidatilor' am definit functia 'minValue': aceasta returneaza primul element in sens al ordinii alfabetice din arborele care reprezinta mutimea 'CA' (bTree* candidates). Functia cu antetul "void findXTree(graph* g,char* name,bTree* candidates,bTree** temp)" este folosita pentru a construi multimea nodurilor care trebuie excluse din multimea 'candidatilor' pentru pasul urmator al algoritmului (functia insereaza in arborele temp nodurile din 'candidates' care in graf nu prezinta adiacenta cu nodul extras la pasul curent).

In cadrul problemei labirintului am definit a structura de tip graf (intitulata 'maze') utilizand liste de adiacenta intrucat am considerat ca aceasta implementare este mai eficienta (pentru fisierele care contin o cantitate mai mare de date de intrare - grafuri cu numar mare de noduri) decat cea care utilizeaza o matrice de costuri. De asemenea, in structura grafului am introdus vectori alocati dinamic pentru retinerea informatiilor suplimentare: vectorul exit pentru a memora indicii camerelor care prezinta iesire din labirint (componeta i a vectorului 'exit' are valoarea 1 daca camera 'i+1' prezinta iesire si -1 in sens contrar) si tabloul bidimensional guards pentru informatii legate de prezenta paznicilor in camere. Fiecare linie a taboului bidimensional 'guards' are urmatoarea structura conforma cu operatiile realizate in functia de citire a grafului: elementul de pe prima coloana (cel de indice 0) contine numarul de momente de timp ale prezentei gardianului si pe urmatoarele pozitii sunt memorate aceste momente de timp (la citirea datelor am alocat pentru fiecare linie a tabloului atat spatiu cat este nevoie).In listele de adiacenta am memorat indicii camerelor asa cum le-am preluat din fisierul de intrare(cu valori cuprinse intre 1 si numarul de camere din labirint) dar si valorea timpului de transfer prin portal (campul 'time'). 
Pentru rezolvarea problemei drumului de cost minim catre iesirea din labirint am adaptat algoritmul lui Dijkstra, determinad drumul de cost minim de la nodul de start la toate celelalte noduri din graf si apoi am cautat in multimea camerelor care prezinta iesiri acea camera care presupune un timp minim de 'evadare'. Modificarea fata de algoritmul clasic este data de prezenta parznicilor in anumite camere: la pasul din algoritm in care este selectat si vizitat un nod am verificat daca acesta presupune prezenta unui paznic la momentul de timp la care s-a ajuns in acea camera (acesta este memorat in vectorul 'dist' in componenta de indice egal cu indicele camerei alese); daca in camera este prezent un paznic continui sa incrementez costul asociat acelui nod pana se ajunge la un moment de timp in care nu mai este prezent paznic in incapere. In continuare sunt actualizate costurile asociate nodurilor adiacente nodului ales anterior. Pentru ca la fiecare din cei n-1 pasi ai algoritmului (n=nr de noduri din graf) sa fie selectat initial acel nod din multimea de noduri nevizitate care presupune cost minim, am defint functia cu antetul "int findMinVertex(int* distances,int* visited,maze* lb)" care returneza valoarea acestui nod (pentru  a face distinctia noduri vizitate-nevizitate am folosit un vector alocat dinamic continand valorile 1 - nod vizitat, -1 - nod nevizitat). Pentru a determina camerele din traseul de cost minim am folosit un vector de indici alocat dinamic in care am memorat pentru fiecare nod precedentul sau din traseu. La final nodurile care alcatuiesc traseul minim sunt memorate in ordine inversa (de la finish la start) intr-un vector alocat dinamic, costruit pe baza vectorului de 'precendeti'. 
Horovei Andreea, 315CC
